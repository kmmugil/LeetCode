import java.util.Arrays;

/**
 * 300. Longest Increasing Subsequence
 * <p>
 * Medium
 * <p>
 * Given an integer array nums, return the length of the longest strictly increasing subsequence.
 * <p>
 * A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].
 */
public class prob_300 {

    public static void main(String[] args) {
        Solution_300 solution = new Solution_300();
//        int[] nums = {10,9,2,5,3,7,101,18};
//        int[] nums = {3,5,6,2,5,4,1,5,6,7,12};
        int[] nums = {1, 4, 8, 5, 3, 2, 0, 3};
//        int[] nums = {0,1,0,3,2,3};
//        int[] nums = {10,9};
        System.out.println(solution.lengthOfLIS_v2(nums));
    }

}

class Solution_300 {

    /**
     * Solution using Dynamic Programming
     * <p>
     * Time Complexity - O(n^2), Space Complexity - O(n)
     * <p>
     * Here the sub-problems are the longest increasing subsequence including the index[i], then calculating the max length from those sub-problems
     */
    public int lengthOfLIS(int[] nums) {
        int[] tab = new int[nums.length];
        int max = 0;
        for (int i = nums.length - 1; i >= 0; i--) {
            for (int j = i; j < nums.length; j++) {
                if (nums[j] > nums[i]) tab[i] = Math.max(tab[i], tab[j]);
            }
            tab[i] += 1;
            max = Math.max(max, tab[i]);
        }
        return max;
    }

    /**
     * Time Complexity - O(nlogn), Space Complexity - O(n)
     * <p>
     * Intuition
     * <p>
     * If we iterate through the entire array left to right and make the most compact increasing array, then we can get the longest increasing subsequence.
     * <p>
     * Compactness can be described by the following example:
     * [1,2,3,4,5] is more compact than [1,10,15,20,30]
     * <p>
     * The idea is that we want to fill our subsequence with the smallest numbers possible so that when comes the next number, we can simply append it to the end of the subsequence.
     * <p>
     * Implementation
     * 1. Initially we make a new array, let the name be I[], initially all the values of the array are
     * infinite, only the 0th element contains negative infinite. The size of I[] will be total
     * elements in the sequence + 1.
     * <p>
     * 2. We iterate from left, and we pick the numbers from Sequence one by one and insert them
     * into I[]. When inserting a number, we find the position where all the numbers in left are
     * strictly smaller than the number (if the position is I.length, append the number, else replace
     * the number in that position)
     * <p>
     * --> Here the numbers when replaced, give rise to a new sequence with all the existing entries
     * lesser than that number. Thus, if the sequence is modified later on, if the increasing property
     * is maintained, all new sequences generated by replacing will be valid
     * <p>
     * 3. If we insert the numbers in this fashion, if you think a while, you will find that the
     * numbers in I[] will always be in ascending order.
     * <p>
     * 4. And another important thing is that, if a number is inserted into the ith place, and all the
     * numbers from 1st place to (i-1)th place are smaller than that, so, the L[] value of that
     * number should be i. It can be proved inductively.
     */
    public int lengthOfLIS_v2(int[] nums) {
        int[] memo = new int[nums.length];
        int count = 1;
        memo[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > memo[count - 1]) {
                memo[count] = nums[i];
                count++;
            } else {
                int idx = Arrays.binarySearch(memo, 0, count, nums[i]);
                idx = idx < 0 ? -(idx + 1) : idx;
                System.out.println("Replacing: " + idx);
                memo[idx] = nums[i];
            }
            System.out.println(Arrays.toString(memo));
        }
        return count;
    }

}